{
  "version": 3,
  "sources": ["../../luby-transform/dist/index.mjs"],
  "sourcesContent": ["import { inflate, deflate } from 'pako';\n\nfunction mergeUint8Arrays(arrays) {\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length + 4, 0);\n  const mergedArray = new Uint8Array(totalLength);\n  let offset = 0;\n  arrays.forEach((arr) => {\n    const length = arr.length;\n    mergedArray[offset++] = length >> 24 & 255;\n    mergedArray[offset++] = length >> 16 & 255;\n    mergedArray[offset++] = length >> 8 & 255;\n    mergedArray[offset++] = length & 255;\n    mergedArray.set(arr, offset);\n    offset += length;\n  });\n  return mergedArray;\n}\nfunction splitUint8Arrays(mergedArray) {\n  const arrays = [];\n  let offset = 0;\n  while (offset < mergedArray.length) {\n    const length = mergedArray[offset++] << 24 | mergedArray[offset++] << 16 | mergedArray[offset++] << 8 | mergedArray[offset++];\n    const arr = mergedArray.slice(offset, offset + length);\n    arrays.push(arr);\n    offset += length;\n  }\n  return arrays;\n}\nfunction appendMetaToBuffer(data, meta) {\n  const json = JSON.stringify(meta);\n  const metaBuffer = stringToUint8Array(json);\n  return mergeUint8Arrays([metaBuffer, data]);\n}\nfunction appendFileHeaderMetaToBuffer(data, meta) {\n  return appendMetaToBuffer(data, meta);\n}\nfunction readMetaFromBuffer(buffer) {\n  const splitted = splitUint8Arrays(buffer);\n  if (splitted.length !== 2) {\n    throw new Error(\"Invalid buffer\");\n  }\n  const [metaBuffer, data] = splitted;\n  const meta = JSON.parse(uint8ArrayToString(metaBuffer));\n  return [data, meta];\n}\nfunction readFileHeaderMetaFromBuffer(buffer) {\n  const [data, meta] = readMetaFromBuffer(buffer);\n  if (!meta.contentType) {\n    meta.contentType = \"application/octet-stream\";\n  }\n  return [data, meta];\n}\nfunction stringToUint8Array(str) {\n  const data = new Uint8Array(str.length);\n  for (let i = 0; i < str.length; i++) {\n    data[i] = str.charCodeAt(i);\n  }\n  return data;\n}\nfunction uint8ArrayToString(data) {\n  return String.fromCharCode(...data);\n}\n\nfunction generateCRCTable() {\n  const crcTable2 = new Uint32Array(256);\n  for (let i = 0; i < 256; i++) {\n    let crc = i;\n    for (let j = 8; j > 0; j--) {\n      if (crc & 1) {\n        crc = crc >>> 1 ^ 3988292384;\n      } else {\n        crc = crc >>> 1;\n      }\n    }\n    crcTable2[i] = crc >>> 0;\n  }\n  return crcTable2;\n}\nconst crcTable = /* @__PURE__ */ generateCRCTable();\nfunction getChecksum(uint8Array, k) {\n  let crc = 4294967295;\n  for (let i = 0; i < uint8Array.length; i++) {\n    const byte = uint8Array[i];\n    crc = crc >>> 8 ^ crcTable[(crc ^ byte) & 255];\n  }\n  return (crc ^ k ^ 4294967295) >>> 0;\n}\n\nfunction blockToBinary(block) {\n  const { k, bytes, checksum, indices, data } = block;\n  const header = new Uint32Array([\n    indices.length,\n    ...indices,\n    k,\n    bytes,\n    checksum\n  ]);\n  const binary = new Uint8Array(header.length * 4 + data.length);\n  let offset = 0;\n  binary.set(new Uint8Array(header.buffer), offset);\n  offset += header.length * 4;\n  binary.set(data, offset);\n  return binary;\n}\nfunction binaryToBlock(binary) {\n  const degree = new Uint32Array(binary.buffer, 0, 4)[0];\n  const headerRest = Array.from(new Uint32Array(binary.buffer, 4, degree + 3));\n  const indices = headerRest.slice(0, degree);\n  const [\n    k,\n    bytes,\n    checksum\n  ] = headerRest.slice(degree);\n  const data = binary.slice(4 * (degree + 4));\n  return {\n    k,\n    bytes,\n    checksum,\n    indices,\n    data\n  };\n}\nfunction xorUint8Array(a, b) {\n  const result = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    result[i] = a[i] ^ b[i];\n  }\n  return result;\n}\n\nfunction createDecoder(blocks) {\n  return new LtDecoder(blocks);\n}\nclass LtDecoder {\n  decodedData = [];\n  decodedCount = 0;\n  encodedCount = 0;\n  encodedBlocks = /* @__PURE__ */ new Set();\n  encodedBlockKeyMap = /* @__PURE__ */ new Map();\n  encodedBlockSubkeyMap = /* @__PURE__ */ new Map();\n  encodedBlockIndexMap = /* @__PURE__ */ new Map();\n  disposedEncodedBlocks = /* @__PURE__ */ new Map();\n  meta = undefined;\n  constructor(blocks) {\n    if (blocks) {\n      for (const block of blocks) {\n        this.addBlock(block);\n      }\n    }\n  }\n  // Add block and decode them on the fly\n  addBlock(block) {\n    if (!this.meta) {\n      this.meta = block;\n      this.decodedData = Array.from({ length: this.meta.k });\n    }\n    if (block.checksum !== this.meta.checksum) {\n      throw new Error(\"Adding block with different checksum\");\n    }\n    this.encodedCount += 1;\n    block.indices = block.indices.sort((a, b) => a - b);\n    this.propagateDecoded(indicesToKey(block.indices), block);\n    return this.decodedCount === this.meta.k;\n  }\n  propagateDecoded(key, block) {\n    const { decodedData, encodedBlocks, encodedBlockIndexMap, encodedBlockKeyMap, encodedBlockSubkeyMap, disposedEncodedBlocks } = this;\n    let index;\n    let blocks;\n    let { data, indices } = block;\n    const indicesSet = new Set(indices);\n    let subblock;\n    let subIndicesSet;\n    if (encodedBlockKeyMap.has(key) || indices.every((i) => decodedData[i] != null)) {\n      return;\n    }\n    if (indices.length > 1) {\n      for (const index2 of indices) {\n        if (decodedData[index2] != null) {\n          block.data = data = xorUint8Array(data, decodedData[index2]);\n          indicesSet.delete(index2);\n        }\n      }\n      if (indicesSet.size !== indices.length) {\n        block.indices = indices = Array.from(indicesSet);\n      }\n    }\n    if (indices.length > 2) {\n      const subkeys = [];\n      for (const index2 of indices) {\n        const subkey = indicesToKey(indices.filter((i) => i !== index2));\n        if (subblock = encodedBlockKeyMap.get(subkey)) {\n          block.data = data = xorUint8Array(data, subblock.data);\n          subIndicesSet = new Set(subblock.indices);\n          for (const i of subIndicesSet) {\n            indicesSet.delete(i);\n          }\n          block.indices = indices = Array.from(indicesSet);\n          break;\n        } else {\n          subkeys.push([index2, subkey]);\n        }\n      }\n      if (indicesSet.size > 1) {\n        subkeys.forEach(([index2, subkey]) => {\n          const dispose = () => encodedBlockSubkeyMap.get(subkey)?.delete(block);\n          encodedBlockSubkeyMap.get(subkey)?.add(block) ?? encodedBlockSubkeyMap.set(subkey, /* @__PURE__ */ new Set([block]));\n          disposedEncodedBlocks.get(index2)?.push(dispose) ?? disposedEncodedBlocks.set(index2, [dispose]);\n        });\n      }\n    }\n    if (indices.length > 1) {\n      block.indices.forEach((i) => {\n        encodedBlocks.add(block);\n        encodedBlockIndexMap.get(i)?.add(block) ?? encodedBlockIndexMap.set(i, /* @__PURE__ */ new Set([block]));\n      });\n      encodedBlockKeyMap.set(key = indicesToKey(indices), block);\n      const superset = encodedBlockSubkeyMap.get(key);\n      if (superset) {\n        encodedBlockSubkeyMap.delete(key);\n        for (const superblock of superset) {\n          const superIndicesSet = new Set(superblock.indices);\n          superblock.data = xorUint8Array(superblock.data, data);\n          for (const i of indices) {\n            superIndicesSet.delete(i);\n          }\n          superblock.indices = Array.from(superIndicesSet);\n          this.propagateDecoded(indicesToKey(superblock.indices), superblock);\n        }\n      }\n    } else if (decodedData[index = indices[0]] == null) {\n      encodedBlocks.delete(block);\n      disposedEncodedBlocks.get(index)?.forEach((dispose) => dispose());\n      decodedData[index] = block.data;\n      this.decodedCount += 1;\n      if (blocks = encodedBlockIndexMap.get(index)) {\n        encodedBlockIndexMap.delete(index);\n        for (const block2 of blocks) {\n          key = indicesToKey(block2.indices);\n          encodedBlockKeyMap.delete(key);\n          this.propagateDecoded(key, block2);\n        }\n      }\n    }\n  }\n  getDecoded() {\n    if (this.decodedCount !== this.meta.k) {\n      return;\n    }\n    if (this.decodedData.some((block) => block == null)) {\n      return;\n    }\n    const sliceSize = this.meta.data.length;\n    const blocks = this.decodedData;\n    const decodedData = new Uint8Array(this.meta.bytes);\n    blocks.forEach((block, i) => {\n      const start = i * sliceSize;\n      if (start + sliceSize > decodedData.length) {\n        for (let j = 0; j < decodedData.length - start; j++) {\n          decodedData[start + j] = block[j];\n        }\n      } else {\n        decodedData.set(block, i * sliceSize);\n      }\n    });\n    try {\n      const decompressed = inflate(decodedData);\n      const checksum = getChecksum(decompressed, this.meta.k);\n      if (checksum === this.meta.checksum) {\n        return decompressed;\n      }\n    } catch {\n      const checksum = getChecksum(decodedData, this.meta.k);\n      if (checksum === this.meta.checksum) {\n        return decodedData;\n      }\n    }\n    throw new Error(\"Checksum mismatch\");\n  }\n}\nfunction indicesToKey(indices) {\n  return indices.join(\",\");\n}\n\nfunction createEncoder(data, sliceSize, compress = true) {\n  return new LtEncoder(data, sliceSize, compress);\n}\nclass LtEncoder {\n  constructor(data, sliceSize, compress = true) {\n    this.data = data;\n    this.sliceSize = sliceSize;\n    this.compress = compress;\n    this.compressed = compress ? deflate(data) : data;\n    this.indices = sliceData(this.compressed, sliceSize);\n    this.k = this.indices.length;\n    this.checksum = getChecksum(this.data, this.k);\n    this.bytes = this.compressed.length;\n  }\n  k;\n  indices;\n  checksum;\n  bytes;\n  compressed;\n  createBlock(indices) {\n    const data = new Uint8Array(this.sliceSize);\n    for (const index of indices) {\n      const indicesIndex = this.indices[index];\n      for (let i = 0; i < this.sliceSize; i++) {\n        data[i] = data[i] ^ indicesIndex[i];\n      }\n    }\n    return {\n      k: this.k,\n      bytes: this.bytes,\n      checksum: this.checksum,\n      indices,\n      data\n    };\n  }\n  /**\n   * Generate random encoded blocks that **never** ends\n   */\n  *fountain() {\n    while (true) {\n      const degree = getRandomDegree(this.k);\n      const selectedIndices = getRandomIndices(this.k, degree);\n      yield this.createBlock(selectedIndices);\n    }\n  }\n}\nfunction sliceData(data, blockSize) {\n  const blocks = [];\n  for (let i = 0; i < data.length; i += blockSize) {\n    const block = new Uint8Array(blockSize);\n    block.set(data.slice(i, i + blockSize));\n    blocks.push(block);\n  }\n  return blocks;\n}\nfunction getRandomDegree(k) {\n  const probabilities = Array.from({ length: k }, () => 0);\n  probabilities[0] = 1 / k;\n  for (let d = 2; d <= k; d++) {\n    probabilities[d - 1] = 1 / (d * (d - 1));\n  }\n  const cumulativeProbabilities = probabilities.reduce((acc, p, index) => {\n    acc.push(p + (acc[index - 1] || 0));\n    return acc;\n  }, []);\n  const randomValue = Math.random();\n  for (let i = 0; i < cumulativeProbabilities.length; i++) {\n    if (randomValue < cumulativeProbabilities[i]) {\n      return i + 1;\n    }\n  }\n  return k;\n}\nfunction getRandomIndices(k, degree) {\n  const indices = /* @__PURE__ */ new Set();\n  while (indices.size < degree) {\n    const randomIndex = Math.floor(Math.random() * k);\n    indices.add(randomIndex);\n  }\n  return Array.from(indices);\n}\n\nexport { LtDecoder, LtEncoder, appendFileHeaderMetaToBuffer, appendMetaToBuffer, binaryToBlock, blockToBinary, createDecoder, createEncoder, mergeUint8Arrays, readFileHeaderMetaFromBuffer, readMetaFromBuffer, splitUint8Arrays, stringToUint8Array, uint8ArrayToString, xorUint8Array };\n"],
  "mappings": "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",
  "names": ["_a"]
}
