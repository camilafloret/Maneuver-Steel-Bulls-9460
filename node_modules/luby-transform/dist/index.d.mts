/**
 * Merge multiple Uint8Array into a single Uint8Array
 * Each chunk is prefixed with a 4-byte Uint32 to store the length of the chunk
 */
declare function mergeUint8Arrays(arrays: Uint8Array[]): Uint8Array<ArrayBuffer>;
/**
 * Split a merged Uint8Array into multiple Uint8Array
 */
declare function splitUint8Arrays(mergedArray: Uint8Array): Uint8Array[];
declare function appendMetaToBuffer<T>(data: Uint8Array, meta: T): Uint8Array;
declare function appendFileHeaderMetaToBuffer(data: Uint8Array, meta: {
    filename?: string;
    contentType?: string;
}): Uint8Array;
declare function readMetaFromBuffer<T>(buffer: Uint8Array): [data: Uint8Array, meta: T];
declare function readFileHeaderMetaFromBuffer(buffer: Uint8Array): [data: Uint8Array, meta: {
    filename?: string;
    contentType: string;
}];
declare function stringToUint8Array(str: string): Uint8Array;
declare function uint8ArrayToString(data: Uint8Array): string;

interface EncodedHeader {
    /**
     * Number of original data blocks
     */
    k: number;
    /**
     * Data length for Uint8Array data
     */
    bytes: number;
    /**
     * Checksum, CRC32 and XOR of k
     */
    checksum: number;
}
interface EncodedBlock extends EncodedHeader {
    indices: number[];
    data: Uint8Array;
}
declare function blockToBinary(block: EncodedBlock): Uint8Array;
declare function binaryToBlock(binary: Uint8Array): EncodedBlock;
declare function xorUint8Array(a: Uint8Array, b: Uint8Array): Uint8Array;

declare function createDecoder(blocks?: EncodedBlock[]): LtDecoder;
declare class LtDecoder {
    decodedData: (Uint8Array | undefined)[];
    decodedCount: number;
    encodedCount: number;
    encodedBlocks: Set<EncodedBlock>;
    encodedBlockKeyMap: Map<string, EncodedBlock>;
    encodedBlockSubkeyMap: Map<string, Set<EncodedBlock>>;
    encodedBlockIndexMap: Map<number, Set<EncodedBlock>>;
    disposedEncodedBlocks: Map<number, (() => void)[]>;
    meta: EncodedBlock;
    constructor(blocks?: EncodedBlock[]);
    addBlock(block: EncodedBlock): boolean;
    propagateDecoded(key: string, block: EncodedBlock): void;
    getDecoded(): Uint8Array | undefined;
}

declare function createEncoder(data: Uint8Array, sliceSize: number, compress?: boolean): LtEncoder;
declare class LtEncoder {
    readonly data: Uint8Array;
    readonly sliceSize: number;
    readonly compress: boolean;
    readonly k: number;
    readonly indices: Uint8Array[];
    readonly checksum: number;
    readonly bytes: number;
    readonly compressed: Uint8Array;
    constructor(data: Uint8Array, sliceSize: number, compress?: boolean);
    createBlock(indices: number[]): EncodedBlock;
    /**
     * Generate random encoded blocks that **never** ends
     */
    fountain(): Generator<EncodedBlock, never>;
}

export { type EncodedBlock, type EncodedHeader, LtDecoder, LtEncoder, appendFileHeaderMetaToBuffer, appendMetaToBuffer, binaryToBlock, blockToBinary, createDecoder, createEncoder, mergeUint8Arrays, readFileHeaderMetaFromBuffer, readMetaFromBuffer, splitUint8Arrays, stringToUint8Array, uint8ArrayToString, xorUint8Array };
