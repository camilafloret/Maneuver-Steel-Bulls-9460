import { inflate, deflate } from 'pako';

function mergeUint8Arrays(arrays) {
  const totalLength = arrays.reduce((sum, arr) => sum + arr.length + 4, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  arrays.forEach((arr) => {
    const length = arr.length;
    mergedArray[offset++] = length >> 24 & 255;
    mergedArray[offset++] = length >> 16 & 255;
    mergedArray[offset++] = length >> 8 & 255;
    mergedArray[offset++] = length & 255;
    mergedArray.set(arr, offset);
    offset += length;
  });
  return mergedArray;
}
function splitUint8Arrays(mergedArray) {
  const arrays = [];
  let offset = 0;
  while (offset < mergedArray.length) {
    const length = mergedArray[offset++] << 24 | mergedArray[offset++] << 16 | mergedArray[offset++] << 8 | mergedArray[offset++];
    const arr = mergedArray.slice(offset, offset + length);
    arrays.push(arr);
    offset += length;
  }
  return arrays;
}
function appendMetaToBuffer(data, meta) {
  const json = JSON.stringify(meta);
  const metaBuffer = stringToUint8Array(json);
  return mergeUint8Arrays([metaBuffer, data]);
}
function appendFileHeaderMetaToBuffer(data, meta) {
  return appendMetaToBuffer(data, meta);
}
function readMetaFromBuffer(buffer) {
  const splitted = splitUint8Arrays(buffer);
  if (splitted.length !== 2) {
    throw new Error("Invalid buffer");
  }
  const [metaBuffer, data] = splitted;
  const meta = JSON.parse(uint8ArrayToString(metaBuffer));
  return [data, meta];
}
function readFileHeaderMetaFromBuffer(buffer) {
  const [data, meta] = readMetaFromBuffer(buffer);
  if (!meta.contentType) {
    meta.contentType = "application/octet-stream";
  }
  return [data, meta];
}
function stringToUint8Array(str) {
  const data = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    data[i] = str.charCodeAt(i);
  }
  return data;
}
function uint8ArrayToString(data) {
  return String.fromCharCode(...data);
}

function generateCRCTable() {
  const crcTable2 = new Uint32Array(256);
  for (let i = 0; i < 256; i++) {
    let crc = i;
    for (let j = 8; j > 0; j--) {
      if (crc & 1) {
        crc = crc >>> 1 ^ 3988292384;
      } else {
        crc = crc >>> 1;
      }
    }
    crcTable2[i] = crc >>> 0;
  }
  return crcTable2;
}
const crcTable = /* @__PURE__ */ generateCRCTable();
function getChecksum(uint8Array, k) {
  let crc = 4294967295;
  for (let i = 0; i < uint8Array.length; i++) {
    const byte = uint8Array[i];
    crc = crc >>> 8 ^ crcTable[(crc ^ byte) & 255];
  }
  return (crc ^ k ^ 4294967295) >>> 0;
}

function blockToBinary(block) {
  const { k, bytes, checksum, indices, data } = block;
  const header = new Uint32Array([
    indices.length,
    ...indices,
    k,
    bytes,
    checksum
  ]);
  const binary = new Uint8Array(header.length * 4 + data.length);
  let offset = 0;
  binary.set(new Uint8Array(header.buffer), offset);
  offset += header.length * 4;
  binary.set(data, offset);
  return binary;
}
function binaryToBlock(binary) {
  const degree = new Uint32Array(binary.buffer, 0, 4)[0];
  const headerRest = Array.from(new Uint32Array(binary.buffer, 4, degree + 3));
  const indices = headerRest.slice(0, degree);
  const [
    k,
    bytes,
    checksum
  ] = headerRest.slice(degree);
  const data = binary.slice(4 * (degree + 4));
  return {
    k,
    bytes,
    checksum,
    indices,
    data
  };
}
function xorUint8Array(a, b) {
  const result = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return result;
}

function createDecoder(blocks) {
  return new LtDecoder(blocks);
}
class LtDecoder {
  decodedData = [];
  decodedCount = 0;
  encodedCount = 0;
  encodedBlocks = /* @__PURE__ */ new Set();
  encodedBlockKeyMap = /* @__PURE__ */ new Map();
  encodedBlockSubkeyMap = /* @__PURE__ */ new Map();
  encodedBlockIndexMap = /* @__PURE__ */ new Map();
  disposedEncodedBlocks = /* @__PURE__ */ new Map();
  meta = undefined;
  constructor(blocks) {
    if (blocks) {
      for (const block of blocks) {
        this.addBlock(block);
      }
    }
  }
  // Add block and decode them on the fly
  addBlock(block) {
    if (!this.meta) {
      this.meta = block;
      this.decodedData = Array.from({ length: this.meta.k });
    }
    if (block.checksum !== this.meta.checksum) {
      throw new Error("Adding block with different checksum");
    }
    this.encodedCount += 1;
    block.indices = block.indices.sort((a, b) => a - b);
    this.propagateDecoded(indicesToKey(block.indices), block);
    return this.decodedCount === this.meta.k;
  }
  propagateDecoded(key, block) {
    const { decodedData, encodedBlocks, encodedBlockIndexMap, encodedBlockKeyMap, encodedBlockSubkeyMap, disposedEncodedBlocks } = this;
    let index;
    let blocks;
    let { data, indices } = block;
    const indicesSet = new Set(indices);
    let subblock;
    let subIndicesSet;
    if (encodedBlockKeyMap.has(key) || indices.every((i) => decodedData[i] != null)) {
      return;
    }
    if (indices.length > 1) {
      for (const index2 of indices) {
        if (decodedData[index2] != null) {
          block.data = data = xorUint8Array(data, decodedData[index2]);
          indicesSet.delete(index2);
        }
      }
      if (indicesSet.size !== indices.length) {
        block.indices = indices = Array.from(indicesSet);
      }
    }
    if (indices.length > 2) {
      const subkeys = [];
      for (const index2 of indices) {
        const subkey = indicesToKey(indices.filter((i) => i !== index2));
        if (subblock = encodedBlockKeyMap.get(subkey)) {
          block.data = data = xorUint8Array(data, subblock.data);
          subIndicesSet = new Set(subblock.indices);
          for (const i of subIndicesSet) {
            indicesSet.delete(i);
          }
          block.indices = indices = Array.from(indicesSet);
          break;
        } else {
          subkeys.push([index2, subkey]);
        }
      }
      if (indicesSet.size > 1) {
        subkeys.forEach(([index2, subkey]) => {
          const dispose = () => encodedBlockSubkeyMap.get(subkey)?.delete(block);
          encodedBlockSubkeyMap.get(subkey)?.add(block) ?? encodedBlockSubkeyMap.set(subkey, /* @__PURE__ */ new Set([block]));
          disposedEncodedBlocks.get(index2)?.push(dispose) ?? disposedEncodedBlocks.set(index2, [dispose]);
        });
      }
    }
    if (indices.length > 1) {
      block.indices.forEach((i) => {
        encodedBlocks.add(block);
        encodedBlockIndexMap.get(i)?.add(block) ?? encodedBlockIndexMap.set(i, /* @__PURE__ */ new Set([block]));
      });
      encodedBlockKeyMap.set(key = indicesToKey(indices), block);
      const superset = encodedBlockSubkeyMap.get(key);
      if (superset) {
        encodedBlockSubkeyMap.delete(key);
        for (const superblock of superset) {
          const superIndicesSet = new Set(superblock.indices);
          superblock.data = xorUint8Array(superblock.data, data);
          for (const i of indices) {
            superIndicesSet.delete(i);
          }
          superblock.indices = Array.from(superIndicesSet);
          this.propagateDecoded(indicesToKey(superblock.indices), superblock);
        }
      }
    } else if (decodedData[index = indices[0]] == null) {
      encodedBlocks.delete(block);
      disposedEncodedBlocks.get(index)?.forEach((dispose) => dispose());
      decodedData[index] = block.data;
      this.decodedCount += 1;
      if (blocks = encodedBlockIndexMap.get(index)) {
        encodedBlockIndexMap.delete(index);
        for (const block2 of blocks) {
          key = indicesToKey(block2.indices);
          encodedBlockKeyMap.delete(key);
          this.propagateDecoded(key, block2);
        }
      }
    }
  }
  getDecoded() {
    if (this.decodedCount !== this.meta.k) {
      return;
    }
    if (this.decodedData.some((block) => block == null)) {
      return;
    }
    const sliceSize = this.meta.data.length;
    const blocks = this.decodedData;
    const decodedData = new Uint8Array(this.meta.bytes);
    blocks.forEach((block, i) => {
      const start = i * sliceSize;
      if (start + sliceSize > decodedData.length) {
        for (let j = 0; j < decodedData.length - start; j++) {
          decodedData[start + j] = block[j];
        }
      } else {
        decodedData.set(block, i * sliceSize);
      }
    });
    try {
      const decompressed = inflate(decodedData);
      const checksum = getChecksum(decompressed, this.meta.k);
      if (checksum === this.meta.checksum) {
        return decompressed;
      }
    } catch {
      const checksum = getChecksum(decodedData, this.meta.k);
      if (checksum === this.meta.checksum) {
        return decodedData;
      }
    }
    throw new Error("Checksum mismatch");
  }
}
function indicesToKey(indices) {
  return indices.join(",");
}

function createEncoder(data, sliceSize, compress = true) {
  return new LtEncoder(data, sliceSize, compress);
}
class LtEncoder {
  constructor(data, sliceSize, compress = true) {
    this.data = data;
    this.sliceSize = sliceSize;
    this.compress = compress;
    this.compressed = compress ? deflate(data) : data;
    this.indices = sliceData(this.compressed, sliceSize);
    this.k = this.indices.length;
    this.checksum = getChecksum(this.data, this.k);
    this.bytes = this.compressed.length;
  }
  k;
  indices;
  checksum;
  bytes;
  compressed;
  createBlock(indices) {
    const data = new Uint8Array(this.sliceSize);
    for (const index of indices) {
      const indicesIndex = this.indices[index];
      for (let i = 0; i < this.sliceSize; i++) {
        data[i] = data[i] ^ indicesIndex[i];
      }
    }
    return {
      k: this.k,
      bytes: this.bytes,
      checksum: this.checksum,
      indices,
      data
    };
  }
  /**
   * Generate random encoded blocks that **never** ends
   */
  *fountain() {
    while (true) {
      const degree = getRandomDegree(this.k);
      const selectedIndices = getRandomIndices(this.k, degree);
      yield this.createBlock(selectedIndices);
    }
  }
}
function sliceData(data, blockSize) {
  const blocks = [];
  for (let i = 0; i < data.length; i += blockSize) {
    const block = new Uint8Array(blockSize);
    block.set(data.slice(i, i + blockSize));
    blocks.push(block);
  }
  return blocks;
}
function getRandomDegree(k) {
  const probabilities = Array.from({ length: k }, () => 0);
  probabilities[0] = 1 / k;
  for (let d = 2; d <= k; d++) {
    probabilities[d - 1] = 1 / (d * (d - 1));
  }
  const cumulativeProbabilities = probabilities.reduce((acc, p, index) => {
    acc.push(p + (acc[index - 1] || 0));
    return acc;
  }, []);
  const randomValue = Math.random();
  for (let i = 0; i < cumulativeProbabilities.length; i++) {
    if (randomValue < cumulativeProbabilities[i]) {
      return i + 1;
    }
  }
  return k;
}
function getRandomIndices(k, degree) {
  const indices = /* @__PURE__ */ new Set();
  while (indices.size < degree) {
    const randomIndex = Math.floor(Math.random() * k);
    indices.add(randomIndex);
  }
  return Array.from(indices);
}

export { LtDecoder, LtEncoder, appendFileHeaderMetaToBuffer, appendMetaToBuffer, binaryToBlock, blockToBinary, createDecoder, createEncoder, mergeUint8Arrays, readFileHeaderMetaFromBuffer, readMetaFromBuffer, splitUint8Arrays, stringToUint8Array, uint8ArrayToString, xorUint8Array };
